# Домашнее задание к занятию «Микросервисы: принципы»

## Выполнил студент группы DevOps-25 Шаповалов Кирилл

<br />

Задача 1: API Gateway
---------------------

```
Предложите решение для обеспечения реализации API Gateway. Составьте сравнительную таблицу 
возможностей различных программных решений. На основе таблицы сделайте выбор решения.

Решение должно соответствовать следующим требованиям:

- маршрутизация запросов к нужному сервису на основе конфигурации,
- возможность проверки аутентификационной информации в запросах,
- обеспечение терминации HTTPS.

Обоснуйте свой выбор.
```

### Решение

API шлюзов на текущий день огромное множество, так, например, у каждого крупного облачного провайдера есть свой шлюз: AWS API-Gateway, Azure API-Gateway, Oracle API-Gateway, даже вроде у Yandex.Cloud есть свой API-Gateway. Их функционал я рассматривать не буду, все же в РФ пока еще облака не настолько популярны, как на Западе, а потому у нас большим спросом пользуются opensource решения с широким комьюнити. Такими решениями, например, являются: Nginx, HAProxy, Kong и другие.

Рассмотрим некоторые из таких решений:

|    API Gateway     |     Маршрутизация     |     Аутентификация    |     Терминация HTTPS    |
|--------------------|-----------------------|-----------------------|-------------------------|
| Nginx              |          ✓            |          ✓           |             ✓           |
| HAProxy            |          ✓            |          ✓           |             ✓           |
| Kong Gateway       |          ✓            |          ✓           |             ✓           |           
| Ocelot             |          ✓            |          ✓           |             ✓           |
| TYK Gateway        |          ✓            |          ✓           |             ✓           |
| | | | |

Как видно из сравнения, все рассмотренные решения (и не только эти) обладают требуемыми по заданию функциями, а при этом еще и поддерживают многие другие возможности.

Так, например, все данные решения поддерживают механизмы балансировки трафика, авторизации и аутентификации, несколько возможных протоколов, например Ocelot поддерживает GraphQL помимо HTTP методов (по крайней мере, так заявлено в официальной документации).

Что касается выбора для реализации - я бы остановился на первых трех строчках, и вот почему:

1. Nginx и HAProxy - есть опыт эксплуатации, очень часто используемые решения, хорошо реализуют балансировку и отказоустойчивость в паре с утилитой `keepalived`, просто масштабировать и расширять, широкое комьюнити и огромное количество документации в различном виде - и официальная документация, и статьи на Хабре, и видеогайды и т.д.
2. Kong Gateway - хоть у меня и нет практического опыта эксплуатации данного инструмента, однако по официальной документации заявлено, что данное решение является максимально простым в настройке и масштабировании, разрабатывался специально для микросервисной архитектуры, построен на базе Nginx, что также обеспечивает его большим количеством документации и широким комьюнити, основной функционал можно расширять за счет различных дополнительных плагинов, которых тоже немало.

<br />

Задача 2: Брокер сообщений
--------------------------

```
Составьте таблицу возможностей различных брокеров сообщений. 
На основе таблицы сделайте обоснованный выбор решения.

Решение должно соответствовать следующим требованиям:

- поддержка кластеризации для обеспечения надёжности,
- хранение сообщений на диске в процессе доставки,
- высокая скорость работы,
- поддержка различных форматов сообщений,
- разделение прав доступа к различным потокам сообщений,
- простота эксплуатации.

Обоснуйте свой выбор.
```

### Решение

Когда заходит речь про брокеры сообщений, сразу же на ум приходят два решения: Apache Kafka и RabbitMQ. Посмотрим и сравним эти два решения и что еще может предложить рынок ПО.

| Брокер | Кластеризация | Хранение на диске | Высокая скорость | Разные форматы | Разделение доступов | Простота |
|--------|---------------|-------------------|------------------|----------------|---------------------|----------|
| Kafka  |       ✓       |        ✓          |        ✓        |    ✓           |  ✓                 |   ✓      |
|RabbitMQ|       ✓       |        ✓          |        ✓        |✓               |  ✓                 |   ✓      |
|Redis   |       ✓       | ✓                 |         ✓       |✓               |  ✓                  |   ✓     |

Да, почти каждый брокер сообщений поддерживает все запрашиваемые функции, однако на каждый брокер нужно смотреть в разрезе поставленной задачи, поскольку работают они совершенно по-разному.

Например, **Redis** хорош для быстрых данных, так как предоставляет хранение данных в памяти. Количество сообщений в секунду - до 1млн. Обладает механизмом кластеризации. Можно настроить сброс данных на диск или в БД. Хорошо подходит для обмена сообщениями в реальном времени. Однако, следует помнить про очень большой минус Redis - однопоточность.

**RabbitMQ** поддерживает около 50тыс. сообщений в секунду, обладает простотой и гибкостью в настройках. Поддерживает сложную маршрутизацию сообщений. Однако, у RabbitMQ есть сложности в настройке кластеризации, требуется написание дополнительных надстроек над очередями, что приводит к потере в гибкости и простоте системы. Хорошо подходит в тех случаях, когда важна внутренняя маршрутизация и факт доставки сообщения, так как здесь гарантируется доставка и после доставки сообщение удаляется.

**Kafka** - наверное самый универсальный брокер. Здесь так же поддерживается до 1млн сообщений в секунду, более того - этот объем можно наращивать. Устроен брокер проще, чем RabbitMQ, выполняя по сути две функции - получить сообщение и отдать. Клиенты сами подключаются и забирают свои сообщения. Позволяет перечитывать сообщения пачками, что значительно ускоряет работу. Однако есть проблемы в обработке сообщений - чтобы обработать следующее сообщение - нужно обязательно отпустить текущее, таким образом есть риск потерять битое сообщение. Требуется отдельно настраивать хранение битых сообщений. В целом хорошо подходит для конвейерных систем с большим потоком данных, так как обладает огромной пропускной способностью.

Исходя из описанного выше - выбор конкретного брокера сообщений сильно зависит от контекста задачи. Как наиболее универсальный вариант я бы выбрал наверное Kafka.